import { readFile } from "node:fs/promises";
import path from "node:path";

import { getWantedLockfileName } from "./lockfileName";
import { comverToSemver, stripBom } from "./utils";

// bundled dependencies
import { WANTED_LOCKFILE } from "@pnpm/constants";
import type { Lockfile, ProjectSnapshot } from "@pnpm/lockfile-types";

// direct dependencies
import yaml from "js-yaml";
import semver from "semver";
import { DEPENDENCIES_FIELDS } from "@pnpm/types";

export type PnpmLockfileFile = Omit<Lockfile, "importers"> &
	Partial<ProjectSnapshot> &
	Partial<Pick<Lockfile, "importers">>;

export type ReadOpts = {
	overrideFileName?: string;
	wantedVersions?: string[];
	ignoreIncompatible: boolean;
	useGitBranchLockfile?: boolean;

	// the following options have been removed (they are not used in unlocked)
	// mergeGitBranchLockfiles?: never;
	// autofixMergeConflicts?: never;
};

export async function readWantedLockfile(pkgPath: string, opts: ReadOpts): Promise<Lockfile | null> {
	const lockfileNames: string[] = [opts.overrideFileName ?? WANTED_LOCKFILE];
	if (opts.useGitBranchLockfile) {
		const gitBranchLockfileName: string = await getWantedLockfileName(pkgPath, opts);
		if (gitBranchLockfileName !== lockfileNames[0]) lockfileNames.unshift(gitBranchLockfileName);
	}

	let result: Lockfile | null = null;
	for (const lockfileName of lockfileNames) {
		result = await _read(path.join(pkgPath, lockfileName), { ...opts });
		if (result) break;
	}

	if (!result) {
		if (opts.ignoreIncompatible) return null;
		throw new Error(`No lockfile found in ${pkgPath}`);
	}

	return result;
}

async function _read(lockfilePath: string, opts: ReadOpts): Promise<Lockfile | null> {
	let lockfileRawContent;
	try {
		lockfileRawContent = stripBom(await readFile(lockfilePath, "utf8"));
	} catch (err: unknown) {
		if ((err as NodeJS.ErrnoException).code !== "ENOENT") throw err;

		return null;
	}

	return parseLockfileContents({ lockfileRawContent, lockfilePath, opts });
}

export const parseLockfileContents = async ({
	lockfileRawContent,
	lockfilePath = WANTED_LOCKFILE,
	opts,
}: {
	lockfileRawContent: string;
	lockfilePath?: string;
	opts: ReadOpts;
}) => {
	let lockfileFile: PnpmLockfileFile;
	try {
		lockfileFile = yaml.load(lockfileRawContent) as Lockfile;
	} catch (err: unknown) {
		throw new Error(`Cannot parse ${lockfilePath}: ${err}`);
	}

	if (lockfileFile) {
		// pnpm uses revertFromInlineSpecifiersFormatIfNecessary here to revert changes from the "forceInlineSpecifiers" write option if necessary.
		// This is not necessary for unlocked, this option will just be unsupported for now.

		const lockfile = convertFromLockfileFileMutable(lockfileFile);
		const lockfileSemver = comverToSemver((lockfile.lockfileVersion ?? 0).toString());
		/* eslint-enable @typescript-eslint/dot-notation */
		if (
			!opts.wantedVersions ||
			opts.wantedVersions.length === 0 ||
			opts.wantedVersions.some((wantedVersion) => {
				if (semver.major(lockfileSemver) !== semver.major(comverToSemver(wantedVersion))) return false;
				if (semver.gt(lockfileSemver, comverToSemver(wantedVersion))) {
					console.warn(
						`Your ${WANTED_LOCKFILE} was generated by a newer version of pnpm. It is a compatible version but it might get downgraded to version ${wantedVersion}`,
					);
				}
				return true;
			})
		) {
			return lockfile;
		}
	}

	if (opts.ignoreIncompatible) {
		console.warn(`Ignoring not compatible lockfile at ${lockfilePath}`);
		return null;
	}

	throw new Error(`Lockfile ${lockfilePath} is not compatible with the current pnpm version`);
};

/**
 * Reverts changes from the "forceSharedFormat" write option if necessary.
 */
function convertFromLockfileFileMutable(lockfileFile: PnpmLockfileFile): Lockfile {
	if (typeof lockfileFile?.["importers"] === "undefined") {
		lockfileFile.importers = {
			".": {
				specifiers: lockfileFile["specifiers"] ?? {},
				dependenciesMeta: lockfileFile["dependenciesMeta"],
				publishDirectory: lockfileFile["publishDirectory"],
			},
		};
		lockfileFile.specifiers = undefined;
		for (const depType of DEPENDENCIES_FIELDS) {
			if (lockfileFile[depType] != null) {
				lockfileFile.importers["."]![depType] = lockfileFile[depType];
				lockfileFile[depType] = undefined;
			}
		}
	}
	return lockfileFile as Lockfile;
}
